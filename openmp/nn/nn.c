#include <math.h>
#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_ARGS 10
#define REC_LENGTH 49     // size of a record in db
#define REC_WINDOW 262144 // number of records to read at a time
#define LATITUDE_POS 28   // location of latitude coordinates in input record
#define OPEN 10000        // initial value of nearest neighbors
struct Neighbor {
  char entry[REC_LENGTH];
  double dist;
};

__attribute__((packed)) struct Record {
  int year;
  int month;
  int date;
  int hour;
  int num;
  int speed;
  int press;
  float lat;
  float lon;
  char name[10];
};

/**
 * This program finds the k-nearest neighbors
 * Usage:	./nn <filelist> <num> <target latitude> <target longitude>
 *             <threads>
 * filelist: File with the filenames to the records
 * num: Number of nearest neighbors to find
 * target lat: Latitude coordinate for distance calculations
 * target long: Longitude coordinate for distance calculations
 * binary: whether the input is binary format.
 * threads: number of threads.
 *
 * The filelist and data are generated by hurricane_gen.c
 * REC_WINDOW has been arbitrarily assigned; A larger value would allow more
 * work for the threads
 */

#ifndef IS_BINARY
#define IS_BINARY 1
#endif

#if IS_BINARY == 1
struct Record sandbox[REC_WINDOW];
#else
char sandbox[REC_LENGTH * REC_WINDOW];
#endif

void process(FILE *flist, struct Neighbor *neighbors, int k, float target_lat,
             float target_long) {

  char dbname[64];
  if (fscanf(flist, "%s\n", dbname) != 1) {
    fprintf(stderr, "error reading filelist\n");
    exit(0);
  }

  FILE *fp = fopen(dbname, "r");
  if (!fp) {
    printf("error opening flist\n");
    exit(1);
  }

  float *z = (float *)malloc(REC_WINDOW * sizeof(float));

  int done = 0;
  while (!done) {
// Read in REC_WINDOW number of records
#if IS_BINARY == 1
    size_t rec_count = fread(sandbox, sizeof(struct Record), REC_WINDOW, fp);
#else
    size_t rec_count = fread(sandbox, REC_LENGTH, REC_WINDOW, fp);
#endif
    if (rec_count != REC_WINDOW) {
      if (!ferror(flist)) { // an eof occured
        fclose(fp);

        if (feof(flist))
          done = 1;
        else {
          if (fscanf(flist, "%s\n", dbname) != 1) {
            fprintf(stderr, "error reading filelist\n");
            exit(0);
          }

          fp = fopen(dbname, "r");

          if (!fp) {
            printf("error opening a db\n");
            exit(1);
          }
        }
      } else {
        perror("Error");
        exit(0);
      }
    }

#pragma omp parallel for shared(z, target_lat, target_long) schedule(static)
    for (int i = 0; i < rec_count; i++) {
#if IS_BINARY == 1
      float tmp_lat = sandbox[i].lat;
      float tmp_long = sandbox[i].lon;
#else
      char *rec_iter = sandbox + (i * REC_LENGTH + LATITUDE_POS - 1);
      float tmp_lat = atof(rec_iter);
      float tmp_long = atof(rec_iter + 5);
#endif
      z[i] = sqrt(((tmp_lat - target_lat) * (tmp_lat - target_lat)) +
                  ((tmp_long - target_long) * (tmp_long - target_long)));
    }

    for (int i = 0; i < rec_count; i++) {
      float max_dist = -1;
      int max_idx = 0;
      // find a neighbor with greatest dist and take his spot if allowed!
      for (int j = 0; j < k; j++) {
        if (neighbors[j].dist > max_dist) {
          max_dist = neighbors[j].dist;
          max_idx = j;
        }
      }
      // compare each record with max value to find the nearest neighbor
      if (z[i] < neighbors[max_idx].dist) {
#if IS_BINARY == 1
        strcpy(neighbors[max_idx].entry, sandbox[i].name);
#else
        sandbox[(i + 1) * REC_LENGTH - 1] = '\0';
        strcpy(neighbors[max_idx].entry, sandbox + i * REC_LENGTH);
#endif
        neighbors[max_idx].dist = z[i];
      }
    }
  } // End while loop
}

int main(int argc, char *argv[]) {
  long long time0 = clock();

  if (argc < 6) {
    fprintf(stderr, "Invalid set of arguments\n");
    exit(-1);
  }

  FILE *flist = fopen(argv[1], "r");
  if (!flist) {
    printf("error opening flist\n");
    exit(1);
  }

  int k = atoi(argv[2]);
  float target_lat = atof(argv[3]);
  float target_long = atof(argv[4]);
  int threads = atoi(argv[5]);
  omp_set_num_threads(threads);

  struct Neighbor *neighbors = malloc(k * sizeof(struct Neighbor));
  if (neighbors == NULL) {
    fprintf(stderr, "no room for neighbors\n");
    exit(1);
  }
  for (int j = 0; j < k; j++) {
    // Initialize list of nearest neighbors to very large dist
    neighbors[j].dist = OPEN;
  }

  /**** main processing ****/
  process(flist, neighbors, k, target_lat, target_long);

  fprintf(stderr, "The %d nearest neighbors are:\n", k);
  for (int j = 0; j < k; j++) {
    if (!(neighbors[j].dist == OPEN))
      fprintf(stderr, "%s --> %f\n", neighbors[j].entry, neighbors[j].dist);
  }

  fclose(flist);

  long long time1 = clock();
  printf("total time : %15.12fs\n", (float)(time1 - time0) / 1000000);
  return 0;
}
